# 贪心算法
## 简介
###  dp 介绍
最简单的就是枚举所有的可能性，然后选取最优的一组合
所有组合是： O(2^n) 次


动态规划：动态规划表面上很难，其实存在很简单的套路：当求解的问题满足以下两个条件时，就应该使用动态规划：   
1. 主问题的答案 包含了 可分解的子问题答案 (也就是说，问题可以被递归的思想求解)  
2. 递归求解时，很多子问题的答案会被多次重复利用  
3. 动态规划的本质思想就是递归，但如果直接应用递归方法，子问题的答案会被重复计算产生浪费, 同时递归更加耗费栈内存，所以通常用一个二维矩阵（表格）来表示不同子问题的答案,以实现更加高效的求解,使用scala,haskell等可以更高效的实现类似的结构和方法  
4. 问题边界，就是递归的退出条件！


reference:
http://blog.csdn.net/MrLevo520/article/details/75676160

### dp抽象出来的元素:  
1. weight 元素重量列表  
2. value 元素价值列表  
3. container: c, 能容纳的重量数目   
4. 求最优和sum(价值)  

使用中间二位数组来存储最大的结果:  




### 递归和动态规划的比较  
递归是自上而下的划分问题，因为有堆栈可以存储上一次的结果，所以递归是比较方便的开发。注意递归有退出边界条件   
动态规划是自下而上的累计问题，并且下一次的求解可以使用到上一次的最优解！   
动态规划可以解决更复杂的问题！   

递归和动态规划是可以相互转换的！
经典的比较： 
爬楼梯的例子！

reference:
https://blog.csdn.net/register_man/article/details/79226837


### 递归和备忘录方法
递归中可能会重复计算已经产生的值，使用备忘录方法，用一个全局变量保存递归中产生的中间结果，再下一次递归的时候可以不用再计算，经典的使用例子就是fibonacci计算方法.


### 各种模型处理方法
1.线性模型
2.区间模型
3.背包模型

https://blog.csdn.net/u013309870/article/details/75193592



